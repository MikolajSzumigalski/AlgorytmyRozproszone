<!doctype html>
<html>

<head>
    <title>Algorytmy Rozproszone</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
    <link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-blue-grey.css">
    <link rel="stylesheet" href="style.css">

    <link href="https://fonts.googleapis.com/css?family=Armata|Encode+Sans|Josefin+Sans|Lato" rel="stylesheet">


</head>

<body>
    <div class="w3-container w3-teal w3-theme-d1">
        <h1>Algorytmy rozproszone</h1>
        <h4>Na samym wstępie chciałbym zaznaczyć, że większość materiałów pochodzi z książki: Hagit Attiya "<a href="http://students.wmi.amu.edu.pl:20002/zajecia/file-storage/view/artyku-y/alr-pliki/distrib_alg-Attiya%2epdf">Distributed algorithms</a>" i jest ona nieudolną próbą przekładu jej części na język polski. </h4>
    </div>
    <div class="w3-container w3-teal w3-theme-l4">
        <h2>Model <i>message passing</i></h2>
        <h3>Wstęp</h3>
        <p>Na początku skupimy się na <i>message passing systems</i> jednych z najważniejszych modeli dla systemów rozproszonych. Message passing system jest opisywany za pomocą <b>grafów komunikacyjnych</b> w których wierzchołki grafów są reprezentowane poprzez procesory i (nieskierowane) krawędzie reprezentowane przez kanały komunikacyjne pomiędzy tymi procesorami. Każdy procesor jest niezależną jednostką wyposażoną we własną <b>pamięć</b>, która jest wykorzystywana podczas programu lokalnego. Lokalny program zawiera operacje wewnętrzne, wysyła komunikaty, oraz oczekuje na komunikaty (na kilku krawędziach). Alogrytmy dla systemu są zbiorem lokalnych programów dla różnych procesorów. Wykonaniem algorytmu jest przeplatane wykonanie lokalnych programów (zawierające pewne ograniczenia i zasady)</p>
        <p>Kilka wariantów systemów message passing były badane w teorii przetwarzania rozproszonego. Te warianty możemy rozróżnić według następujących funkcji:</p>
        <ul class="w3-ul w3-card-4">
            <li><b>Graf komunikacyjny:</b> Ten graf może mieć standardową formę np. pierścienia, może być arbitralny</li>
            <li><b>Stopień synchroniczności:</b> System może być <i>synchroniczny</i>, gdzie obliczenia są wykonywane w <i>rundach</i>. Na początku rundy każdy procesor wysyła komunikaty i oczekuje na komunikaty, które są wysyłane przez sąsiadów w tej rundzie. Po otrzymaniu tych wiadomości procesory wykonują operacje i decydują, które komunikaty są wysyłane w następnej rundzie. W systemie <i>asynchronicznym</i> procesory działają w różnych czasach. Dodatkowo mogą ponosić nieograniczone i nieprzeiwywalne (ale skończone) opóźnienie. Istnieją również modele pośrednie dla tych dwóch, których nie będziemy tu omawiać.</li>
            <li><b>Stopień regularności:</b> w systemach <i>anonimowych</i> wszystkie procesory są identyczne, nierzróżnialne czyli bez <b>id</b> czy innych nazw.</li>
            <li><b>Jednolitość:</b> W <i>jednolitych</i> systemach procesory nie wiedzą ile jest wszystkich procesorów. W konsekwencji procesory wykonują ten sam program bez względu na wielkość systemu i potrafią w związku z tym używać ich do wykonywania różnych programów według wielkości systemu.</li>
        </ul>
        <p>Powyższe charakterystyki i kilka innych specyfikacji są dokładnym modelem systemu <i>model passing</i>. Jak możemy zauważyć w wielu sytuacjach te charakterystyki mogą przynieść fantastyczny efekt w postaci mocy systemu. Możemy zobaczyć problemy które mogę być rozwiązane łatwiej w jednym modelu, podczas gdy inny model wymaga więcej zasobów i wymagań do rozwiązania go. Ponadto możemy zobaczyć problemy, które da się rozwiązać tylko w jednym modelu.</p>
        <h3>1.1 Definicja modelu obliczeniowego</h3>
        <p>Przedstawmy zarys podstawowych elementów formalnego systemu message passing.</p>
        <p>Obliczenia w tych systemach są wykonywane w sekwencji konfiguracji. We wstęnej konfiguracji procesory są w stanie początkowym, a krawędzie są puste. Wykonanie algorytmu słada się z wydarzeń: możliwe zdarzenia są wykonywane przez procesor w początkowej operacji, komunikat wysyłany przez krawędź i dostarczany w pzeznaczone miejsce. Każde zdarzenie zarówno zmiana stanu procesora, lub zmiana krawędzi a tym samym zmiana konfiguracji systemu.</p>
        <p>Mówiąc dokładniej, mamy <i>algorytm</i> składający się z <b>n</b> procesorów: p1...pn. Każdy procesor <i>p</i> jest zamodelowany jako (możliwie nieskończony) automat stanów z zestawem stanów <b>Q</b>. Zestaw stanów <b>Q</b> zawiera wyróżniony <i>stan początkowy q0</i>. Zakładamy że stan procesora <i>pi</i> zawiera specjalny komponent <i>buff</i> w którym nadchodzące komunikaty są <b>buforowane</b> (bufor to obszar pamięci służąc do tymczasowego przechowywania danych przesyłanych między dwoma systemami, a buforowanie to technologia je wykorzystująca w celu wyrównania różnic prędkości przesyłania danych).</p>
        <p><i>Układ</i> jest wektorem <i>C = (q1...qn)</i> gdzie <i>qi</i> jest lokalnym stanem <i>pi</i>. <i>Wtępny układ</i> jest wektorem (q01,...q0n). Procesory komunikją się poprzez wysyłanie <i>komunikatów</i> (pobranych z alfabetu <b>M</b>) do siebie nawzajem. <i>Wysłanie akcji send(i, j, m)</i> reprezentuje wysłanie wiadomości <i><b>m</b></i> z <i><b>pi</b></i> do <i><b>pj</b></i>. Dla każdego <b><i>i, 1<= i <= n</i></b> niech <i><b>Si</b></i> oznacza ustalenie wszystkich akcji <i>send(i,j,m)</i> dla każdego <i>m</i> &isin; M i każdego <i>j</i>, <i>1 <= j <=n</i>.</p>
        <p>Modelujemy obliczenia algorytmu jako sekwencję konfiguracji zmiennej ze <i>zdarzeniami</i>. Każde zdarzenie jest zarówno <i>zdarzeniem obliczeniowym</i>, reprezentowanym jako obliczeniowe kroki dla pojedynczego procesora lub jako <i>zdarzenie dostarczenia</i>, reprezentujący dostarczenie wiadomości do procesora</p>
        <p>Zdarzenie obliczeniowe jest określone przez <i><b>comp(i, S)</b></i> gdzie <i><b>i</b></i> jest indeksem procesora wykonującego krok i <i><b>S</b></i> będący skończonym podzbiorem <i><b>Si</b></i>. W obliczeniach krok powiązany ze zdarzeniem <i>comp(i, S)</i>, procesor <i>pi</i>, oparty na lokalnym stanie wykonuje akcję <i>wysłania</i> w <i>S</i> i możliwe zmiany w lokalnych stanach. Każde dostarczenie zdarzenia jest w formie <i>del(i,j,m)</i> dla wielu <b>m</b> &isin; <b>M</b>. W dostarczonym kroku powiązanym z komunikatem <i>del(i, j m)</i> wiadomość <i>m</i> z <i>pi</i> jest dodawana do <i>buffj</i>.</p>
        <p><i>Segment wykonywany &alpha;</i> algorytmu jest (skończoną lub nieskończoną) sekwencją w następującej formie:</p>
        <p>
            <center><i><b>C0, &Phi;0, C1, &Phi;1, C2, &Phi;2, ... </b></i></center>
        </p>
        <p>gdzie <i>Ck</i> jest ułożeniem, a &Phi; jest zdarzeniem. Ponadto zgłoszenie <i>&Phi;k</i> do <i>Ck</i> tworzy <i>Ck+1</i> w naturalny sposób. Tak jest jeśli <i>&Phi;k</i> jest lokalnym zdarzeniem obliczeniowym procesora <i>pi</i>, gdzie stan <i>pi</i> w <i>Ck+i</i> i jest zdarzeniem wysyłającym komunikat która jest wynikiem stosowania pi'tej funkcji przejścia dla stanu <i>pi</i> w <i>Ck</i>; jeśli <i>&Phi;k</i> jest wysyłanym komunikatem, lub dostarczonym zdarzeniem gdzie stan właściwych krawędzi jest zmieniany odpowiednio. (To są jedyne zmiany) </p>
        <p> Przyjmujemy konwencję, że skończone wykonywane segmenty kończą się z układem. Jeśli &alpha; jest skończonym wykonywanym segmentem, wtedy <i>Cend(&alpha;)</i> oznacza ostatni uklad &alpha;. </p>
        <p><i>Wykonanie</i> jest  wykonaniem segmentu <i><b>C0, &Phi;0, C1, &Phi;1, C2, &Phi;2, ... </b></i> gdzie <i>C0</i> jest wstępnym układem. Z każdym wykonaniem kojarzymy <i>rozkład</i>, któy jest sekwencją zdarzeń w wykonaniu, czyli <i>&Phi;0, &Phi;1, &Phi;2...</i>. Zwróćmy uwagę, że lokalne programy są deterministyczne, więc wykonanie jest jednoznacznie określone dla wstępnego układu i rozkładu</p>
        <p>W większości przypadków chcemy stawiać dalsze wymagania dla wykonań takie jak: wszystkie komunikaty są ostatecznie dostarczone. To jest uchwycone przez pojęcie <i>dopuszczalności</i></p>
        <p>W modelu asynchronicznym wykonanie jest <i>dopuszczalne</i> jeśli każdy procesor posiada skończoną liczbę zdarzeń obliczeniowych, oraz jest jeden-do-jeden zmapowane z wysłanej akcji do późniejszego zdarzenia dostarczenia (To gwarantuje że każdy komunikat wysłany jest dostarczony dla kilku późniejszych punktów wykonania). Czasami zakładamy, że procesor <i>pi</i> posiada zdarzenie obliczeniowe natychmiast po każdym zdarzeniu dotarczenia dla schematu <i>del(j,i,m)</i>. W tym wyadku, łączymy komunikaty zdarzeń dostarczenia i zdarzeń obliczeniowych oraz odnosimy się do obliczeń pobranych z procesora po otrzymaniu komunikatu.</p>
        <p>W modelu synchronicznym procesory uruchamiają się w lock-step. Wykonanie jest <i>dopuszczalne</i> jeśli oprócz asynchronicznych ograniczeń dopuszczalności wymienionych wcześniej, zdarzenia obliczeniowe występują w <i>rundach</i>. Zakładamy, że każdy procesor posiada dokładnie jedno zdarzenie obliczeniowe w każdej rundzie i że zdarzenia obliczeniowe dla rundy <i><b>r</b></i> występują po zdarzeniach obliczeniowych dla rundy <i><b>r - 1</b></i>. Ponadto przyjmujemy wszysktkie wiadomości wysyłane w rundzie <i><b>r</b></i> są dostarczone przed zdarzeniem obliczeniowym rundy <i><b>r + 1</b></i>.</p>
        <h3> Omówienie tej części</h3>
        <p>W następnych rozdziałach będziemy omawiali kilka podstawowych algorytmów i "lower bounds" przeważnie na złożonych komunikatach dla obliczeń w systemach message passing. Zaczniemy od problemu <b>wyboru lidera</b> w sieciach <i>ring</i>, który reprezentuje szereg problemów z łamaniem regularności. Zaprezentujemy niższe i wyższe granice dla liczby wiadomości wymaganych do wyboru lidera, dla modeli synchronicznych i asynchronicznych. Następny rozdział zademonstruje wybór lidera w sieciach kompletnych. Następnie wrócimy do systemów message passing z dowolną siecią komunikacyjną. Omówimy problem problem minimalnego drzewa spinającego w sieci ogólnej. Potem pokażemy jak stworzyć kilka synchronizatorów w sieci ogólnej. Synchronizer pozwala na rozpoczęcie algorytmów przeznaczonych dla synchronicznych i asynchronicznych systemów.</p>
        <p>W tej części zakładamy, że procesory i łączniki komunikacyjne są niezawodne i funkcjonują prawidłowo. Bedziemy wracać do problemów tolerancji na błędy w późniejszych częściach.</p>
    </div>
    <div class="w3-container w3-teal w3-theme-l5">
        <h2>Wybór lidera w pierścieniach</h2>
        <p>Zaczniemy nasze omówienie systemów message passing od zrozumienia których grafach komunikacyjnych występuje pierścień. Pierścienie są bardzo wygodnymi strukturami dla systemów message passing i odpowiadają  fizycznym systemom komunikacji jak np. pierścienie z tokenem (token rings). Zbadamy problem <i>wyboru lidera</i> w którym procesory muszą "wybrać" jeden z procesorów do bycia liderem. Istnienie lidera może uprościć </p>
    </div>
    <footer class="w3-container w3-theme-d3">
        Page created by: Szumimajster with using <a href="https://www.w3schools.com/w3css/">w3.css</a>
    </footer>
</body>

</html>
